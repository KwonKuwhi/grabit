import { Injectable } from '@nestjs/common';
import { ChallengeDto } from './dto/challenge.dto';
import {
  challenge,
  authentication,
  authentication_img_emoticon,
} from './schema';
import { account, score, users } from '../user/schema';
import { notification } from '../notification/schema';
import { db } from '../../../db/db';
import { eq, not, and, desc, arrayOverlaps, sql, AnyTable } from 'drizzle-orm';
import {
  isBefore,
  isAfter,
  addHours,
  addMonths,
  subDays,
  differenceInDays,
  addDays,
} from 'date-fns';
import { Cron, CronExpression } from '@nestjs/schedule';
import { datetime } from 'drizzle-orm/mysql-core';

@Injectable()
export class ChallengeService {
  // Ï±åÎ¶∞ÏßÄ ÏÉùÏÑ±
  newChallenge = async (
    login_userid_num: number,
    login_nickname: string,
    body: ChallengeDto,
  ) => {
    let {
      challenge_name,
      is_public,
      topic,
      auth_keyword,
      challenger_userid_num,
      goal_money,
      term,
      authentication_start_date,
      authentication_end_date,
      authentication_start_time,
      authentication_end_time,
    } = body;

    let challenger_userid_num2 = [];
    for (let i = 0; i < challenger_userid_num.length; i++) {
      challenger_userid_num2.push(challenger_userid_num[i]);
    }
    challenger_userid_num2.push(login_userid_num);

    // Ï±åÎ¶∞ÏßÄ ÏÉùÏÑ±ÌïòÎäî Ïú†Ï†Ä Ï†ïÎ≥¥ Ï∞æÏïÑÏò§Í∏∞
    let userMoney: any = await db
      .select({ carrot: users.carrot })
      .from(users)
      .where(eq(users.userid_num, login_userid_num));
    userMoney = userMoney[0].carrot;

    let hasMoney = false;

    // ÎÇ¥Í∏∞ Í∏àÏï°Î≥¥Îã§ Ïú†Ï†ÄÏùò ÏûîÍ≥†Í∞Ä ÎßéÏïÑÏïº Ï±åÎ¶∞ÏßÄ ÏÉùÏÑ± Í∞ÄÎä•
    if (userMoney >= goal_money) {
      let challengers = [];
      for (let i = 0; i < challenger_userid_num2.length; i++) {
        if (Number(challenger_userid_num2[i]) !== login_userid_num) {
          challengers.push({
            userid_num: challenger_userid_num2[i],
            isAccept: false,
            resultConfirm: false,
          });
        } else {
          challengers.push({
            userid_num: challenger_userid_num2[i],
            isAccept: true,
            resultConfirm: false,
          });
        }
      }

      // Ï±åÎ¶∞ÏßÄ ÌÖåÏù¥Î∏îÏóê Ï∂îÍ∞ÄÌïòÍ∏∞
      let newChallenge: any = await db
        .insert(challenge)
        .values({
          challenge_name,
          userid_num: login_userid_num,
          is_public,
          topic,
          auth_keyword,
          challenger_userid_num: challengers,
          goal_money,
          term,
          authentication_start_date: new Date(authentication_start_date),
          authentication_end_date: new Date(authentication_end_date),
          authentication_start_time,
          authentication_end_time,
        })
        .returning(); // ÏÉùÏÑ±ÌïòÍ≥† Î∞îÎ°ú Í∞ùÏ≤¥Î°ú Î∞òÌôòÎ∞õÏïÑÏÑú Í∞í ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏùå
      newChallenge = newChallenge[0];

      // notification ÌÖåÏù¥Î∏îÏóê Ï∂îÍ∞ÄÌïòÍ∏∞
      const challengeNotification = [];
      let noti: any;
      for (let i = 0; i < challenger_userid_num2.length; i++) {
        // Ï±åÎ¶∞ÏßÄÎ•º ÏÉùÏÑ±ÌïòÎäî Ïú†Ï†ÄÎ•º Ï†úÏô∏ÌïòÍ≥† ÏïåÎûå Î≥¥ÎÇ¥Ï£ºÍ∏∞
        if (Number(challenger_userid_num2[i]) !== login_userid_num) {
          noti = await db.insert(notification).values({
            userid_num: Number(challenger_userid_num2[i]),
            reference_id: newChallenge.challenge_id,
            message: {
              challengeName: newChallenge.challenge_name,
              inviterName: login_nickname,
            },
            type: 'challenge/create',
            is_confirm: false,
          });
          challengeNotification.push(noti);
        }
      }

      // Ï±åÎ¶∞ÏßÄ ÏÉùÏÑ±Îê† Îïå Ï±åÎ¶∞ÏßÄ ÏÉùÏÑ±ÌïòÎäî Ïú†Ï†Ä moneyÎûë account Í≥ÑÏÇ∞ÌïòÍ∏∞
      const money = await db
        .update(users)
        .set({
          carrot: sql`${users.carrot} - ${newChallenge.goal_money}`,
        })
        .where(eq(users.userid_num, login_userid_num));

      const accountInfo = await db.insert(account).values({
        transaction_description: 'challenge/participation',
        transaction_type: 'carrot/withdraw',
        transaction_amount: newChallenge.goal_money,
        status: false,
        userid_num: login_userid_num,
      });

      hasMoney = true;

      return { newChallenge, challengeNotification, hasMoney };
    } else if (goal_money < 0) {
      return { msg: 'ÎßàÏù¥ÎÑàÏä§ Í∞íÏùÄ ÏûÖÎ†•Ïù¥ Î∂àÍ∞ÄÎä• Ìï©ÎãàÎã§.', hasMoney };
    } else {
      return { msg: 'Ï∫êÎüøÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.', hasMoney };
    }
  };

  // Ï±åÎ¶∞ÏßÄ ÏàòÎùΩ
  challengeAccept = async (userid_num: number, challenge_id: number) => {
    // Ï±åÎ¶∞ÏßÄ ÏÉùÏÑ±ÌïòÎäî Ïú†Ï†Ä Ï†ïÎ≥¥ Ï∞æÏïÑÏò§Í∏∞
    let userMoney: any = await db
      .select({ carrot: users.carrot })
      .from(users)
      .where(eq(users.userid_num, userid_num));
    userMoney = userMoney[0].carrot;
    const challengeWait: any = await db
      .select({
        goal_money: challenge.goal_money,
        challenger_userid_num: challenge.challenger_userid_num,
      })
      .from(challenge)
      .where(eq(challenge.challenge_id, challenge_id));

    if (userMoney >= challengeWait[0].goal_money) {
      for (let i = 0; i < challengeWait.length; i++) {
        if (challengeWait[i].userid_num === userid_num) {
          challengeWait[i].isAccept = true;
        }
      }
      // ÏàòÎùΩÌïòÎ©¥ Ïú†Ï†Ä ÌÖåÏù¥Î∏îÏóêÏÑú money ÏàòÏ†ïÌïòÍ≥† , account Í∏∞Î°ù ÎÇ®Í≤®Ï£ºÍ∏∞
      // Ï±åÎ¶∞ÏßÄ ÏàòÎùΩÌï† Îïå Ï±åÎ¶∞ÏßÄ Ïú†Ï†Ä moneyÎûë account Í≥ÑÏÇ∞ÌïòÍ∏∞
      const money = await db
        .update(users)
        .set({
          carrot: sql`${users.carrot} - ${challengeWait[0].goal_money}`,
        })
        .where(eq(users.userid_num, userid_num));

      const accountInfo = await db.insert(account).values({
        transaction_description: 'challenge/participation',
        transaction_type: 'carrot/withdraw',
        transaction_amount: challengeWait[0].goal_money,
        status: false,
        userid_num: userid_num,
      });

      return await db
        .update(challenge)
        .set({
          challenger_userid_num: challengeWait[0].challenger_userid_num,
        })
        .where(eq(challenge.challenge_id, challenge_id));
    } else
      return {
        msg: 'Ï∫êÎüøÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.',
      };
  };

  // Ï±åÎ¶∞ÏßÄ Í±∞Ï†à
  challengeReject = async (
    login_userid_num: number,
    login_nickname: string,
    challenge_id: number,
  ) => {
    let challengeWait: any = await db
      .select({ challenger_userid_num: challenge.challenger_userid_num })
      .from(challenge)
      .where(eq(challenge.challenge_id, challenge_id));
    challengeWait = challengeWait[0].challenger_userid_num;
    let newChallengeWait = [];
    for (let i = 0; i < challengeWait.length; i++) {
      if (challengeWait[i].userid_num !== login_userid_num) {
        newChallengeWait.push(challengeWait[i]);
      }
    }
    // console.log('service challengeReject challengeWait > ', newChallengeWait);

    const updateChallenge = await db
      .update(challenge)
      .set({
        challenger_userid_num: newChallengeWait,
      })
      .where(eq(challenge.challenge_id, challenge_id))
      .returning();

    let noti: any;
    noti = await db.insert(notification).values({
      userid_num: updateChallenge[0].userid_num,
      reference_id: updateChallenge[0].challenge_id,
      message: {
        challengeName: updateChallenge[0].challenge_name,
        rejectorName: login_nickname,
      },
      type: `challenge/reject/${login_userid_num}`,
      is_confirm: false,
    });

    if (updateChallenge[0].challenger_userid_num.length == 0) {
      noti = await db.insert(notification).values({
        userid_num: updateChallenge[0].userid_num,
        reference_id: updateChallenge[0].challenge_id,
        message: { challengeName: updateChallenge[0].challenge_name },
        type: 'challenge/delete/noChallenger',
        is_confirm: false,
      });
    }

    return updateChallenge;
  };

  // Ï±åÎ¶∞ÏßÄ Î™©Î°ù
  challengeList = async (userid_num: number) => {
    const today = `${new Date().getFullYear()}-${new Date().getMonth()}-${new Date().getDate()}`;
    const challengeAll = await db.select().from(challenge);
    let myChallenge = [];

    for (let i = 0; i < challengeAll.length; i++) {
      for (let j = 0; j < challengeAll[i].challenger_userid_num.length; j++) {
        if (
          challengeAll[i].challenger_userid_num[j].userid_num === userid_num
        ) {
          myChallenge.push(challengeAll[i]);
        }
      }
    }
    console.log('service challengeList myChallenge > ', myChallenge);
    // Ï∞∏Ïó¨Ï§ëÏù∏ Ï±åÎ¶∞ÏßÄ
    let ingMyChallenge = [];
    for (let i = 0; i < myChallenge.length; i++) {
      if (
        isBefore(myChallenge[i].authentication_start_date, new Date()) &&
        isAfter(myChallenge[i].authentication_end_date, new Date())
      ) {
        ingMyChallenge.push(myChallenge[i]);
      }
    }

    // Ï∞∏Í∞Ä ÏòàÏ†ï Ï±åÎ¶∞ÏßÄ
    let preMyChallenge = [];
    for (let i = 0; i < myChallenge.length; i++) {
      if (isAfter(myChallenge[i].authentication_start_date, new Date())) {
        preMyChallenge.push(myChallenge[i]);
      }
    }

    // Ï¢ÖÎ£åÎêú Ï±åÎ¶∞ÏßÄ
    let endedMyChallenge = [];
    for (let i = 0; i < myChallenge.length; i++) {
      if (isBefore(myChallenge[i].authentication_end_date, new Date())) {
        for (let j = 0; j < myChallenge[i].challenger_userid_num.length; j++) {
          if (
            myChallenge[i].challenger_userid_num[j].userid_num === userid_num
          ) {
            if (myChallenge[i].challenger_userid_num[j].resultConfirm === false)
              endedMyChallenge.push(myChallenge[i]);
          }
        }
      }
    }
    console.log(
      'üöÄ ~ ChallengeService ~ challengeList= ~ endedMyChallenge:',
      endedMyChallenge,
    );

    // Ïó¥Î†§ÏûàÎäî Ï±åÎ¶∞ÏßÄ
    const publicChallengeAll = await db
      .select()
      .from(challenge)
      .where(eq(challenge.is_public, true));
    let publicChallenge = [];
    for (let i = 0; i < publicChallengeAll.length; i++) {
      for (
        let j = 0;
        j < publicChallengeAll[i].challenger_userid_num.length;
        j++
      ) {
        if (
          publicChallengeAll[i].challenger_userid_num[j].userid_num !==
          userid_num
        ) {
          publicChallenge.push(publicChallengeAll[i]);
        }
      }
    }
    let prePublicChallenge = [];
    for (let i = 0; i < publicChallenge.length; i++) {
      if (isAfter(publicChallenge[i].authentication_start_date, new Date())) {
        prePublicChallenge.push(publicChallenge[i]);
      }
    }
    return {
      ingMyChallenge,
      preMyChallenge,
      endedMyChallenge,
      prePublicChallenge,
    };
  };

  // Ïù∏Í∏∞ ÏûàÎäî Ï±åÎ¶∞ÏßÄ Ï£ºÏ†ú
  getPopularChallenge = async () => {
    const topics = await db.select({ topic: challenge.topic }).from(challenge);
    let topicCounts = [
      { name: 'Ïö¥Îèô', count: 0 },
      { name: 'ÏÖÄÌîÑÏºÄÏñ¥', count: 0 },
      { name: 'ÎèÖÏÑú', count: 0 },
      { name: 'ÌïôÏäµ', count: 0 },
      { name: 'Ï∑®ÎØ∏', count: 0 },
      { name: 'ÏÉùÌôúÏäµÍ¥Ä', count: 0 },
      { name: 'Ï†ÄÏ∂ï', count: 0 },
    ];
    for (let i = 0; i < topics.length; i++) {
      if (topics[i].topic === 'Ïö¥Îèô') topicCounts[0].count++;
      else if (topics[i].topic === 'ÏÖÄÌîÑÏºÄÏñ¥') topicCounts[1].count++;
      else if (topics[i].topic === 'ÎèÖÏÑú') topicCounts[2].count++;
      else if (topics[i].topic === 'ÌïôÏäµ') topicCounts[3].count++;
      else if (topics[i].topic === 'Ï∑®ÎØ∏') topicCounts[4].count++;
      else if (topics[i].topic === 'ÏÉùÌôúÏäµÍ¥Ä') topicCounts[5].count++;
      else if (topics[i].topic === 'Ï†ÄÏ∂ï') topicCounts[6].count++;
    }
    // count Í∏∞Ï§ÄÏúºÎ°ú ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
    topicCounts.sort((a, b) => b.count - a.count);
    const popularTopic = topicCounts.slice(0, 3);
    console.log('popularTopic > ', popularTopic);
    const popularTopics = popularTopic.map((topic) => topic.name);
    console.log('s3middleware service popularTopics', popularTopics);
    const top1 = await db
      .select()
      .from(challenge)
      .where(eq(challenge.topic, popularTopics[0]))
      .orderBy(desc(challenge.created_at))
      .limit(3);
    const top2 = await db
      .select()
      .from(challenge)
      .where(eq(challenge.topic, popularTopics[1]))
      .orderBy(desc(challenge.created_at))
      .limit(3);
    const top3 = await db
      .select()
      .from(challenge)
      .where(eq(challenge.topic, popularTopics[2]))
      .orderBy(desc(challenge.created_at))
      .limit(3);
    return { popularTopics, top1, top2, top3 };
  };

  // Ï±åÎ¶∞ÏßÄ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Î≥¥Í∏∞
  challengeDetail = async (
    login_userid_num: number,
    challenge_id: number,
    file: any,
  ) => {
    if (file !== null) {
      // Ï°¥Ïû¨ ÌïòÏßÄ ÏïäÎäî Ï±åÎ¶∞ÏßÄÏóê ÎåÄÌïú ÏòàÏô∏ Ï≤òÎ¶¨
      const { urls, challengers } = file;
      const challengeDetail = await db
        .select()
        .from(challenge)
        .where(eq(challenge.challenge_id, challenge_id));

      // Î°úÍ∑∏Ïù∏Ìïú Ïú†Ï†ÄÍ∞Ä Ï±åÎ¶∞ÏßÄ Ïù∏Ï¶ù Í∞ÄÎä•Ìïú ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏
      let isAcceptable: boolean = true;
      let auth_num = 0;

      // Ìï¥Îãπ Ï±åÎ¶∞ÏßÄÏóêÏÑú Î°úÍ∑∏Ïù∏Ìïú Ïú†Ï†ÄÍ∞Ä Ïù∏Ï¶ùÌïú ÎÇ¥Ïó≠ÏùÑ Î™®Îëê Ï∞æÏïÑÏÑú Î∞∞Ïó¥Î°ú Ï†ÄÏû•
      const myAuth = await db
        .select()
        .from(authentication)
        .where(
          and(
            eq(authentication.challenge_id, challengeDetail[0].challenge_id),
            eq(authentication.userid_num, login_userid_num),
          ),
        );
      let today = new Date().toLocaleString('en-US', {
        timeZone: 'Asia/Seoul',
      });
      today = today.split(',')[0];
      const year: number = Number(today.split('/')[2]);
      const month: number = Number(today.split('/')[0]);
      const day: number = Number(today.split('/')[1]);
      // console.log('service today > ', today);

      const period = differenceInDays(
        challengeDetail[0].authentication_end_date,
        challengeDetail[0].authentication_start_date,
      );

      let firstWeek;
      let lastWeek;
      const startDate = challengeDetail[0].authentication_start_date
        .toLocaleString('en-US', {
          timeZone: 'Asia/Seoul',
        })
        .split(',')[0]
        .split('/');
      const endDate = challengeDetail[0].authentication_end_date
        .toLocaleString('en-US', {
          timeZone: 'Asia/Seoul',
        })
        .split(',')[0];

      // ÏùºÏ£ºÏùºÏî© Ï≤¥ÌÅ¨ÌïòÎäî Í∏∞Í∞ÑÏù¥ 2Ï£ºÏù¥Î©¥ Ï¢ÖÎ£åÎÇ†ÏßúÍ∞Ä Ï£ºÍ∞Ä ÎÅùÎÇòÎäî ÎëêÎ≤àÏß∏ ÏãúÏ†ê
      if (period >= 14) {
        lastWeek = addDays(
          new Date(
            Number(startDate[2]),
            Number(startDate[0]) - 1,
            Number(startDate[1]),
          ),
          14,
        )
          .toLocaleString('en-US', {
            timeZone: 'Asia/Seoul',
          })
          .split(',')[0];
      }

      // Ïù∏Ï¶ù Í∏∞Í∞ÑÏù¥ ÏùºÏ£ºÏùºÏù¥Í±∞ÎÇò Îëê Î≤àÏß∏ Ïùº Îïå Ï≤´ Î≤àÏß∏ Ïù∏Ï¶ù Ï≤¥ÌÅ¨ ÏãúÏ†ê
      if (period >= 7) {
        firstWeek = addDays(
          new Date(
            Number(startDate[2]),
            Number(startDate[0]) - 1,
            Number(startDate[1]),
          ),
          7,
        )
          .toLocaleString('en-US', {
            timeZone: 'Asia/Seoul',
          })
          .split(',')[0];
      }

      if (challengeDetail[0].term == 7) {
        // Îß§Ïùº Ïù∏Ï¶ù
        let last = myAuth.length;
        // Ïù∏Ï¶ù Ï≤´ ÎÇ†Ïóê ÎåÄÌïú ÌôïÏù∏
        if (last > 0) {
          let lastAuth = myAuth[last - 1].created_at
            .toLocaleString('en-US', {
              timeZone: 'Asia/Seoul',
            })
            .split(',')[0];
          let yesterday: any = subDays(new Date(year, month - 1, day), 1);
          yesterday = yesterday
            .toLocaleString('en-US', {
              timeZone: 'Asia/Seoul',
            })
            .split(',')[0];
          if (lastAuth != yesterday) isAcceptable = false;
        }
      } else if (challengeDetail[0].term == 3) {
        // Ï£º 3Ìöå Ïù∏Ï¶ù
        if (today === firstWeek) {
          if (myAuth.length < 3) isAcceptable = false;
        }
        if (today === lastWeek) {
          if (myAuth.length < 6) isAcceptable = false;
        }
      } else if (challengeDetail[0].term) {
        // Ï£º 5Ìöå Ïù∏Ï¶ù
        if (today === firstWeek) {
          if (myAuth.length < 5) isAcceptable = false;
        }
        if (today === lastWeek) {
          if (myAuth.length < 10) isAcceptable = false;
        }
      }

      return { challengeDetail, challengers, urls, isAcceptable };
    } else return { msg: 'Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ï±åÎ¶∞ÏßÄÏûÖÎãàÎã§.' };
  };

  // Ï±åÎ¶∞ÏßÄ ÏàòÏ†ï ÌéòÏù¥ÏßÄ Î≥¥Í∏∞
  getChallengeEdit = async (challenge_id: number) => {
    const challengeDetail = await db
      .select()
      .from(challenge)
      .where(eq(challenge.challenge_id, challenge_id));

    return challengeDetail;
  };

  // Ï±åÎ¶∞ÏßÄ ÏàòÏ†ïÌïòÍ∏∞
  patchChallengeEdit = async (body: ChallengeDto, challenge_id: number) => {
    const {
      challenge_name,
      topic,
      auth_keyword,
      goal_money,
      term,
      authentication_start_date,
      authentication_end_date,
      authentication_start_time,
      authentication_end_time,
    } = body;

    let updateChallenge: any = await db
      .update(challenge)
      .set({
        challenge_name: challenge_name,
        topic: topic,
        auth_keyword: auth_keyword,
        goal_money: goal_money,
        term: term,
        authentication_start_date: new Date(authentication_start_date),
        authentication_end_date: new Date(authentication_end_date),
        authentication_start_time: authentication_start_time,
        authentication_end_time: authentication_end_time,
        updated_at: new Date(),
      })
      .where(eq(challenge.challenge_id, challenge_id))
      .returning();

    updateChallenge = updateChallenge[0];

    for (let i = 0; i < updateChallenge.challenger_userid_num.length; i++) {
      if (
        updateChallenge.userid_num !==
        updateChallenge.challenger_userid_num[i].userid_num
      ) {
        let noti = await db.insert(notification).values({
          userid_num: updateChallenge.challenger_userid_num[i].userid_num,
          reference_id: challenge_id,
          message: { challengeName: updateChallenge.challenge_name },
          type: 'challenge/modify',
          is_confirm: false,
        });
      }
    }
    return updateChallenge;
  };

  // Ï±åÎ¶∞ÏßÄ ÏÇ≠Ï†úÌïòÍ∏∞
  deleteChallengeEdit = async (challenge_id: number) => {
    let challengeInfo: any = await db
      .select({
        challenge_id: challenge.challenge_id,
        challenge_name: challenge.challenge_name,
        userid_num: challenge.userid_num,
        challenger_userid_num: challenge.challenger_userid_num,
      })
      .from(challenge)
      .where(eq(challenge.challenge_id, challenge_id));
    challengeInfo = challengeInfo[0];
    console.log(
      'üöÄ ~ ChallengeService ~ deleteChallengeEdit ~ challenger:',
      challengeInfo,
    );
    console.log(challengeInfo.challenger_userid_num.length);
    for (let i = 0; i < challengeInfo.challenger_userid_num.length; i++) {
      if (
        challengeInfo.userid_num !==
        challengeInfo.challenger_userid_num[i].userid_num
      ) {
        let noti = await db.insert(notification).values({
          userid_num: challengeInfo.challenger_userid_num[i].userid_num,
          reference_id: challenge_id,
          message: {
            challengeName: challengeInfo.challenge_name,
          },
          type: 'challenge/delete/byOwner',
          is_confirm: false,
        });
      }
    }

    return await db
      .delete(challenge)
      .where(eq(challenge.challenge_id, challenge_id));

    // ÏùºÎã® ÏïåÎ¶ºÎßå Î≥¥ÎÇ¥Ï£ºÍ≥† 30Ïùº Ïù¥ÌõÑÏóê dbÏóêÏÑú ÏÇ≠Ï†úÌï¥Ï§òÏïº Ìï®. -> ÏïåÎ¶º Ï°∞ÌöåÎê† Îïå ÏóÜÏúºÎ©¥ Ï∂©Îèå Î∞úÏÉùÌïòÍ∏∞ ÎïåÎ¨∏
    // return 'success';
  };

  // Ï±åÎ¶∞ÏßÄ Ïù∏Ï¶ùÌïòÍ∏∞
  newChallengeAuth = async (
    login_userid_num: number,
    challenge_id: number,
    file: string,
  ) => {
    if (file) {
      let fileName: any = file.split('?')[0].split('.com/')[1];

      await db.insert(authentication).values({
        challenge_id: challenge_id,
        userid_num: login_userid_num,
        authentication_img: fileName,
        authentication_status: false,
      });
      return file;
    } else
      return {
        msg: 'Ïù¥ÎØ∏ Ïù∏Ï¶ùÌïòÏã† Ïú†Ï†ÄÏûÖÎãàÎã§.',
      };
  };

  // ÌÖåÏä§Ìä∏ (s3 Ïù¥ÎØ∏ÏßÄ get ÏöîÏ≤≠)
  // Ï±åÎ¶∞ÏßÄ Ïù∏Ï¶ùÏÇ¨ÏßÑ ÏÉÅÏÑ∏ Î≥¥Í∏∞
  getChallengeAuth = async (
    challenge_id: number,
    authentication_id: number,
    fileUrl: any,
  ) => {
    const emoticon = await db
      .select()
      .from(authentication_img_emoticon)
      .where(
        and(
          eq(authentication_img_emoticon.authentication_id, authentication_id),
        ),
      );
    return { fileUrl, emoticon };
  };

  // Ï±åÎ¶∞ÏßÄ Ïù∏Ï¶ùÏÇ¨ÏßÑÏóê ÎåÄÌïú Ïù¥Î™®Ìã∞ÏΩò Ï∑®ÏÜå ÏöîÏ≤≠
  deleteChallengeAuthEmoticon = async (
    challenge_id: number,
    authentication_id: number,
    authentication_img_emoticon_id: number,
    userid_num: number,
  ) => {
    return await db
      .delete(authentication_img_emoticon)
      .where(
        and(
          eq(
            authentication_img_emoticon.authentication_img_comment_emoticon,
            authentication_img_emoticon_id,
          ),
          eq(
            authentication_img_emoticon.authentication_img_comment_userid_num,
            userid_num,
          ),
        ),
      );
  };

  // Ï±åÎ¶∞ÏßÄ Ïù∏Ï¶ùÏÇ¨ÏßÑÏóê ÎåÄÌïú Ïù¥Î™®Ìã∞ÏΩò ÏöîÏ≤≠
  newChallengeAuthEmoticon = async (
    login_userid_num: number,
    body: any,
    challenge_id: number,
    authentication_id: number,
  ) => {
    const { authentication_img_comment_emoticon } = body;
    return await db.insert(authentication_img_emoticon).values({
      authentication_id,
      authentication_img_comment_userid_num: login_userid_num,
      authentication_img_comment_emoticon,
    });
  };

  // ÌÖåÏä§Ìä∏ (s3 Ïù¥ÎØ∏ÏßÄ patch ÏöîÏ≤≠)
  patchChallengeAuth = async (
    challenge_id: number,
    authentication_id: number,
    file: string,
  ) => {
    let fileName: any = file.split('?')[0].split('.com/')[1];

    const updateImg = await db
      .update(authentication)
      .set({
        authentication_img: fileName,
      })
      .where(eq(authentication.authentication_id, authentication_id));
    return file;
  };

  // ÌÖåÏä§Ìä∏ (s3 Ïù¥ÎØ∏ÏßÄ delete ÏöîÏ≤≠)
  deleteChallengeAuth = async (
    challenge_id: number,
    authentication_id: number,
  ) => {
    return await db
      .delete(authentication)
      .where(eq(authentication.authentication_id, authentication_id));
  };

  // Ï±åÎ¶∞ÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
  getChallengeHistory = async (userid_num: number) => {
    // Î™®Îì† Ï±åÎ¶∞ÏßÄ Ï∞æÍ∏∞
    const challengeAll = await db.select().from(challenge);
    let myChallenge = [];
    for (let i = 0; i < challengeAll.length; i++) {
      for (let j = 0; j < challengeAll[i].challenger_userid_num.length; j++) {
        if (
          challengeAll[i].challenger_userid_num[j].userid_num === userid_num &&
          challengeAll[i].challenger_userid_num[j].isAccept === true
        ) {
          myChallenge.push(challengeAll[i]);
        }
      }
    }

    let history = [];
    let today = new Date()
      .toLocaleString('en-US', { timeZone: 'Asia/Seoul' })
      .split(',')[0];
    for (let i = 0; i < myChallenge.length; i++) {
      if (
        isAfter(
          today,
          myChallenge[i].authentication_end_date
            .toLocaleString('en-US', {
              timeZone: 'Asia/Seoul',
            })
            .split(',')[0],
        )
      ) {
        // console.log(
        //   myChallenge[i].authentication_end_date
        //     .toLocaleString('en-US', {
        //       timeZone: 'Asia/Seoul',
        //     })
        //     .split(',')[0],
        // );
        history.push(myChallenge[i]);
      }
    }
    for (let i = 0; i < history.length; i++) {
      let challenger = history[i].challenger_userid_num;
      for (let j = 0; j < challenger.length; j++) {
        let nickname: any = await db
          .select({ nickname: users.nickname })
          .from(users)
          .where(eq(users.userid_num, challenger[j].userid_num));
        nickname = nickname[0].nickname;
        history[i].challenger_userid_num[j] = {
          ...challenger[j],
          nickname: nickname,
        };
        // console.log(
        //   'history challenger_userid_num > ',
        //   history[i].challenger_userid_num,
        // );
      }
    }
    let win = 0, // ÏäπÎ¶¨ ÌöüÏàò
      lose = 0; // Ìå®Î∞∞ ÌöüÏàò
    const total = history.length; // Ï¥ù Ï±åÎ¶∞ÏßÄ ÌöüÏàò
    for (let i = 0; i < history.length; i++) {
      if (
        history[i].winner_userid_num !== null &&
        history[i].winner_userid_num.includes(Number(userid_num))
      )
        win++;
      else lose++;
    }
    return { history, total, win, lose };
  };

  // challenge ÏäπÏûê ÏóÖÎç∞Ïù¥Ìä∏
  async challengeWinner(
    winner: any,
    challenge_id: number,
    userid_num: number,
    challengerInfo: any,
  ) {
    // "resultConfirm : true"Î°ú Î∞îÍøîÏ£ºÍ∏∞
    let challengeInfo: any;
    let preConfirmData: any = await db
      .select({ challenger_userid_num: challenge.challenger_userid_num })
      .from(challenge)
      .where(eq(challenge.challenge_id, challenge_id));
    preConfirmData = preConfirmData[0].challenger_userid_num;
    let confirmData: any = [];
    for (let i = 0; i < preConfirmData.length; i++) {
      if (preConfirmData[i].userid_num === userid_num) {
        confirmData.push({
          ...preConfirmData[i],
          resultConfirm: true,
        });
      } else
        confirmData.push({
          ...preConfirmData[i],
        });
    }
    // Ï±åÎ¶∞ÏßÄÏóê ÎåÄÌïú Ï†ïÎ≥¥ Ï°∞Ìöå
    challengeInfo = await db
      .select()
      .from(challenge)
      .where(eq(challenge.challenge_id, challenge_id));
    challengeInfo = challengeInfo[0];

    let user: any = {};
    for (let i = 0; i < preConfirmData.length; i++) {
      user = preConfirmData[i];
      if (user.userid_num === userid_num) {
        if (user.resultConfirm === false) {
          let updateConfirm = await db
            .update(challenge)
            .set({ challenger_userid_num: confirmData })
            .where(eq(challenge.challenge_id, challenge_id))
            .returning();

          let winners = winner.winner_userid_num;

          // Ï¥ù ÏÉÅÍ∏à
          let totalMoney = winner.total_money;
          console.log(totalMoney);

          // Î™áÎ™ÖÏù¥ Ï∞∏Í∞ÄÌñàÎäîÏßÄ Ï∞æÍ∏∞
          let totalPeople: any = await db
            .select({ challenger_userid_num: challenge.challenger_userid_num })
            .from(challenge)
            .where(eq(challenge.challenge_id, challenge_id));
          totalPeople = totalPeople[0].challenger_userid_num;
          totalPeople = totalPeople.length;
          console.log('Ï¥ù Ï∞∏Í∞Ä Ïù∏Ïõê', totalPeople);

          // 1Ïù∏Îãπ Ï†úÏ∂úÌïú Í∏àÏï°
          let onePerson = totalMoney / totalPeople;

          // Check the user table money
          let checkMoney = await db
            .select({ carrot: users.carrot })
            .from(users)
            .where(eq(users.userid_num, userid_num));

          const userMoney = checkMoney[0].carrot;

          let win = 'none';
          let carrot: number;

          // Ïù¥Í∏¥ ÏÇ¨ÎûåÏù¥ ÏóÜÏùÑ Îïå
          if (winners === undefined || winners.length === 0) {
            console.log('no winner');
            win = 'none';
            const loseScore = await db.insert(score).values({
              userid_num: userid_num,
              score_description: 'Ï±åÎ¶∞ÏßÄ Ïã§Ìå®...',
              score_type: 'lose',
              score: -50,
            });

            // Ïú†Ï†ÄÏùò Ï†êÏàò Í∞êÏÜå ÏãúÌÇ§Í∏∞
            const addUserTable = await db
              .update(users)
              .set({ score_num: sql`${users.score_num} - 50` })
              .where(eq(users.userid_num, userid_num));

            // challengerInfo ÎÇ¥Ïó≠ ÏóÖÎç∞Ïù¥Ìä∏(Ï∫êÎüø Ï∂îÍ∞Ä)
            for (let i = 0; i < challengerInfo.length; i++) {
              challengerInfo[i] = {
                ...challengerInfo[i],
                carrot: -challengeInfo.goal_money,
                score: -50,
              };
            }
          } else {
            win = 'someone';

            // Ïù¥Í∏¥ ÏÇ¨ÎûåÏù¥ ÏûàÏùÑ Îïå winner Ï∂îÍ∞ÄÌïòÍ∏∞
            const addWinner = await db
              .update(challenge)
              .set({ winner_userid_num: winners })
              .where(eq(challenge.challenge_id, challenge_id));

            // 3.3% Ïö¥ÏòÅ ÏàòÏàòÎ£å
            const companyCharge = totalMoney * 0.033;
            console.log('ÏàòÏàòÎ£å >>> ', companyCharge);

            // ÏõêÍ∏àÏóêÏÑú ÏàòÏàòÎ£åÎ•º Ï†úÏô∏Ìïú Í∏àÏï° Î∞òÏò¨Î¶º
            const leftMoney = Math.round(totalMoney - companyCharge);

            console.log('ÏàòÏàòÎ£åÎ•º Ï†úÏô∏Ìïú Í∏àÏï°', leftMoney);

            // Î™®Îì† Ïù¥Í∏¥ Ïú†Ï†Ä Ï∞æÍ∏∞
            let findWinner: any = await db
              .select({ winner_userid_num: challenge.winner_userid_num })
              .from(challenge)
              .where(eq(challenge.challenge_id, challenge_id));

            findWinner = findWinner[0].winner_userid_num;

            // Î™®Îì† ÏäπÏûêÎ•º Ï°∞Ìöå
            let amIWinner: boolean = false;
            if (winners.includes(userid_num)) {
              amIWinner = true;
            }

            // case 1. Ï∞∏Ïó¨Ìïú Î™®Îì† Ïú†Ï†ÄÍ∞Ä Ïù¥Í≤ºÎã§.
            // ÏõêÎûò ÎèàÏùÑ Í∑∏ÎåÄÎ°ú ÏûÖÍ∏à
            if (totalPeople === findWinner.length) {
              // Ïä§ÏΩîÏñ¥ Ï¶ùÍ∞Ä!
              const addScoreTable = await db.insert(score).values({
                userid_num: userid_num,
                score_description: 'Ï±åÎ¶∞ÏßÄ ÏÑ±Í≥µ!',
                score_type: 'win',
                score: +100,
              });

              // Ïú†Ï†ÄÏùò Ï†êÏàò Ï¶ùÍ∞Ä ÏãúÌÇ§Í∏∞
              const addUserTable = await db
                .update(users)
                .set({ score_num: sql`${users.score_num} + ${100}` })
                .where(eq(users.userid_num, userid_num));

              // ÎÇ¥Í∞Ä ÏõêÎûò Ï∞∏Í∞Ä Ïã†Ï≤≠Ìïú Îèà
              const originalMoney: any = totalMoney / findWinner.length;

              // account Ïóê ÎÇ¥Ïó≠ Ï∂îÍ∞Ä
              const getMoney = await db.insert(account).values({
                userid_num: userid_num,
                transaction_description: 'challenge/success',
                transaction_type: 'carrot/deposit',
                transaction_amount: originalMoney,
                status: false,
              });

              // user ÏûîÍ≥†Ïóê Îèà ÏûÖÍ∏à
              const newMoney = await db
                .update(users)
                .set({ carrot: sql`${users.carrot} + ${originalMoney}` })
                .where(eq(users.userid_num, userid_num));

              // challengerInfo ÎÇ¥Ïó≠ ÏóÖÎç∞Ïù¥Ìä∏(Ï∫êÎüø Ï∂îÍ∞Ä)
              for (let i = 0; i < challengerInfo.length; i++) {
                challengerInfo[i] = {
                  ...challengerInfo[i],
                  carrot: challengeInfo.goal_money,
                  score: 100,
                };
              }
            } else {
              let divMoney: any;
              if (amIWinner) {
                // case 2. Î™®Îì† Ïú†Ï†ÄÍ∞Ä Ïù¥Í∏∞ÏßÄ Î™ªÌñàÎã§. (but! ÎÇòÎäî Ïù¥ÍπÄ )
                // Ïä§ÏΩîÏñ¥ Ï¶ùÍ∞Ä!
                const addScoreTable = await db.insert(score).values({
                  userid_num: userid_num,
                  score_description: 'Ï±åÎ¶∞ÏßÄ ÏÑ±Í≥µ!',
                  score_type: 'win',
                  score: +100,
                });

                // Ïú†Ï†ÄÏùò Ï†êÏàò Ï¶ùÍ∞Ä ÏãúÌÇ§Í∏∞
                const addUserTable = await db
                  .update(users)
                  .set({ score_num: sql`${users.score_num} + 100` })
                  .where(eq(users.userid_num, userid_num));

                // Ï±åÎ¶∞Ï†Ä Ïàò ÎßåÌÅº ÎèàÏùÑ ÎÇòÎà†ÏÑú ÏûÖÍ∏à
                // account ÎÇ¥Ïó≠ Ï∂îÍ∞Ä
                divMoney = Math.round(leftMoney / findWinner.length);
                console.log('Ïù¥Í∏¥ ÏÇ¨Îûå ÎßåÌÅº Îèà ÎÇòÎàÑÍ∏∞ Í≤∞Í≥º >>> ', divMoney);
                const money = await db.insert(account).values({
                  userid_num: userid_num,
                  transaction_description: 'challenge/success',
                  transaction_type: 'carrot/deposit',
                  transaction_amount: divMoney,
                  status: false,
                });
                console.log(
                  'Ïù¥Í∏¥ ÏÇ¨Îûå ÎßåÌÅº Îèà ÎÇòÎàÑÍ∏∞ Í≤∞Í≥º 2 >>> ',
                  typeof divMoney,
                );
                // user ÏûîÍ≥†Ïóê Îèà ÏûÖÍ∏à
                const newMoney = await db
                  .update(users)
                  .set({ carrot: sql`${users.carrot} + ${divMoney}` }) //sql`${users.money} + ${divMoney}`
                  .where(eq(users.userid_num, userid_num));
              } else {
                // case 3. Ïù¥Í∏¥ ÏÇ¨ÎûåÏù¥ Ï°¥Ïû¨ ÌïúÎã§. (but! ÎÇòÎäî Ïßê)

                // score Í∞êÏÜå
                const loseScore = await db.insert(score).values({
                  userid_num: userid_num,
                  score_description: 'Ï±åÎ¶∞ÏßÄ Ïã§Ìå®...',
                  score_type: 'lose',
                  score: -50,
                });
                // Ïú†Ï†ÄÏùò Ï†êÏàò Í∞êÏÜå ÏãúÌÇ§Í∏∞
                const addUserTable = await db
                  .update(users)
                  .set({ score_num: sql`${users.score_num} - 50` })
                  .where(eq(users.userid_num, userid_num));
              }
              console.log('winners >>> ', winners);
              // challengerInfo ÎÇ¥Ïó≠ ÏóÖÎç∞Ïù¥Ìä∏(Ï∫êÎüø Ï∂îÍ∞Ä)
              for (let i = 0; i < winners.length; i++) {
                for (let j = 0; j < challengerInfo.length; j++) {
                  if (winners[i] === challengerInfo[j].userid_num) {
                    challengerInfo[j] = {
                      ...challengerInfo[j],
                      carrot: divMoney,
                      score: 100,
                    };
                  } else {
                    challengerInfo[j] = {
                      ...challengerInfo[j],
                      carrot: -challengeInfo.goal_money,
                      score: -50,
                    };
                  }
                }
              }
            }
          }
        }
      }
    }
    challengeInfo = await db
      .select()
      .from(challenge)
      .where(eq(challenge.challenge_id, challenge_id));
    challengeInfo = challengeInfo[0];
    return { challengeInfo, challengerInfo };
  }

  // challenge ÌÖåÏù¥Î∏îÏóêÏÑú authentication_start_dateÎ°ú Î∂ÄÌÑ∞ 30Ïùº ÏßÄÎÇ¨ÏúºÎ©¥ ÏÇ≠Ï†ú
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async handleCron() {
    const everyChallenge = await db.select().from(challenge);
    // console.log('everyChallenge', everyChallenge);

    const dateNow = addHours(new Date(), 9);

    for (let i = 0; i < everyChallenge.length; i++) {
      const time = everyChallenge[i].authentication_start_date
        .toLocaleString('en-US', {
          timeZone: 'Asia/Seoul',
        })
        .split(',')[0];

      const month = Number(time.split('/')[0]);
      const day = Number(time.split('/')[1]);
      const year = Number(time.split('/')[2]);

      const timeNow = addMonths(new Date(year, month - 1, day), 1);
      // console.log(`timeNow${i} >>> `, timeNow);
      // console.log('dateNow >>> ', dateNow);

      if (dateNow === timeNow || dateNow > timeNow) {
        await db
          .delete(challenge)
          .where(eq(challenge.challenge_id, everyChallenge[i].challenge_id));
      }
    }
    console.log('30ÏùºÏù¥ ÏßÄÎÇú Ï±åÎ¶∞ÏßÄ ÏÇ≠Ï†ú');
  }
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async hendleCron() {
    // Ï±åÎ¶∞ÏßÄ ÏãúÏûë ÎÇ†Ïßú Ï∞æÍ∏∞
    const Challenges = await db.select().from(challenge);

    const dateNow = new Date()
      .toLocaleString('en-US', {
        timeZone: 'Asia/Seoul',
      })
      .split(',');

    for (let i = 0; i < Challenges.length; i++) {
      const challenge_time = Challenges[i].authentication_start_date
        .toLocaleString('en-US', {
          timeZone: 'Asia/Seoul',
        })
        .split(',');

      // Ï±åÎ¶∞ÏßÄ ÏÉùÏÑ±Ïûê ÏïÑÏù¥Îîî
      let myNumber: number = Challenges[i].userid_num;

      //ÌòÑÏû¨ Ï±åÎ¶∞ÏßÄ Number
      let Challenge_num = Challenges[i].challenge_id;

      // Ï±åÎ¶∞ÏßÄÏùò ÎèàÏù¥ ÏñºÎßàÏù∏ÏßÄ ÌôïÏù∏ÌïòÍ∏∞
      let Challenge_money = Challenges[i].goal_money;

      // let findMyChallengeNumber = await db.select({challenge_id: challenge.challenge_id}).from(challenge).where(eq(challenge.userid_num, myNumber))
      if (challenge_time === dateNow || challenge_time < dateNow) {
        for (let p = 0; p < Challenges[i].challenger_userid_num.length; p++) {
          let needDelete = true;

          // ÏÉùÏÑ±ÏûêÍ∞Ä ÏïÑÎãå Ïú†Ï†ÄÍ∞Ä ÏïÑÎãå Ïú†Ï†ÄÍ∞Ä isAcceptÍ∞Ä ÌïòÎÇòÎùºÎèÑ true Ïù¥Î©¥
          if (
            Challenges[i].challenger_userid_num[p].isAccept === true &&
            Challenges[i].challenger_userid_num[p].userid_num !== myNumber
          ) {
            needDelete = false;
          }

          if (needDelete === true) {
            const sendNotification = await db.insert(notification).values({
              userid_num: myNumber,
              reference_id: Challenge_num,
              type: 'challenge/delete/noChallenger',
              message: { challengeName: Challenges[i].challenge_name },
              is_confirm: false,
            });

            // Îèà Ïû¨ÏûÖÍ∏à
            const goBackMoney = await db
              .update(users)
              .set({ carrot: sql`${users.carrot} + ${Challenge_money}` })
              .where(eq(users.userid_num, myNumber));

            // account Í≥ÑÏ¢å Ï†ÑÏ†Å Ï∂îÍ∞Ä
            const intoAccount = await db.insert(account).values({
              transaction_description: 'challenge/deleted',
              transaction_type: 'carrot/deposit',
              transaction_amount: Challenge_money,
              status: false,
              userid_num: myNumber,
            });

            // challenge Delete
            const deleteColumn = await db
              .delete(challenge)
              .where(eq(challenge.challenge_id, Challenge_num));
          }
        }
      }
    }
  }
}
